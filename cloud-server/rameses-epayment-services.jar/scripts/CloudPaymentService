import com.rameses.annotations.*;

class CloudPaymentService {
	
	@Service 
	def self;

	@DataContext('paymentorder')
	def po_db;

	@DataContext('payment_partner_option')
	def optionEm;

	@DataContext('payment')
	def pay_db;

	@DataContext('payment_partner')
	def paypartner_db;

	@Service(dynamic=true) 
	def remoteSvc;

	@Service("DateService")
	def dateSvc;

	@XConnection("gdx-mq")
	def gdx;

	@ProxyMethod 
	public def createPaymentOrder( param ) {
		//get the web fee of partner here. either store it in payment database or field in partner.
		//my suggestion is create a table in this domain, not the partner.	

		param.webfee = 0.0; 
		param.objid = param.paymentrefid;

		def df = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		param.txndate = df.format(param.txndate);

		return po_db.create( param );
	} 

	@ProxyMethod 
	public def cancelPaymentOrder( params ) {
		po_db.find( [objid: params.refno ] ).delete();
		params.action = "epayment:cancel-payment-order";
		gdx.send( params, params.orgcode );
		return "ok";
	} 

	@ProxyMethod
	public def getPostPaymentParams(def o) {
		return [paypartner: o.paypartner];		
	}

	@ProxyMethod 
	public def postPayment( def parms ) {
		//call params here. must intercept
		def payPartner = paypartner_db.find( [objid: parms.paypartnerid] ).first();
		parms.paypartner = payPartner;

		def pmt = self.getPostPaymentParams(parms);
		if(!pmt) throw new Exception("Error in post payment. Parameters passed in posting payment must not be empty;")

		if(!pmt.paypartnerid) throw new Exception("error postPayment. paypartnerid is required");

		//update the payment order here
		def po = po_db.find( [objid: pmt.paymentrefid ] ).first();
		def orgcode = po.orgcode;

		pmt.partner = [objid: pmt.paypartnerid];
		pmt.txndate = dateSvc.getServerDate();
		pmt.orgcode = po.orgcode;

		//we use partnerid to refer to pay partner so as not to disrupt existing code in the lgu.
		def pay = pay_db.create( pmt );

		pay.txntype = po.txntype
		pay.orgcode	= orgcode; 
		pay.partnerid = payPartner.objid; 
		pay.partnercode = payPartner.code;
		pay.refno = po.refno; 
		pay.origin = po.origin;
		pay.txntypename = po.txntypename;
		if(!pay.txntypename) pay.txntypename = pay.txntype;

		//you need the ff for payment. for developers this will not occur in production
		if(!pay.txntype) throw new Exception("error remote postPayment. txntype is required");
        if(!pay.paymentrefid) throw new Exception("error remote postPayment. paymentrefid is required"); 
        if(!pay.tracedate) throw new Exception("error remote postPayment. tracedate is required");
        if(!pay.traceid) throw new Exception("error remote postPayment. traceid is required");    
        if(!pay.partnerid) throw new Exception("error remote postPayment. partnerid is required");    
		if(!pay.partnercode) throw new Exception("error remote postPayment. partnercode is required"); 
        if(!pay.refno) throw new Exception("error remote postPayment. refno is required");    
        if(!pay.origin) throw new Exception("error remote postPayment. origin is required");    
        if(!pay.txntypename) throw new Exception("error remote postPayment. txntypename is required");    
		if(!pay.orgcode) throw new Exception("error remote postPayment. orgcode is required"); 

		pay.action = "epayment:post-payment";
		gdx.send( pay, orgcode );

		//This is returned to give feedback to the web page.
		pmt.info = po;
		return pmt;
	} 

	//this is called back by the gdx-client. we only move the payment order if payment successful downstairs
	@ProxyMethod 
	public def updatePaymentReceipt( def pmt ) {
		//update the payment reference
		pay_db.find( [paymentrefid: pmt.paymentrefid ] ).update( pmt );
		//we also delete payment order and transfer to payment order paid table
		po_db.movePaymentOrderToPaid( [paymentrefid: pmt.paymentrefid ] );
		po_db.find( [objid: pmt.paymentrefid ] ).delete();
	} 

	@ProxyMethod
	public def getPaymentOrder( param ) {
		def o =  po_db.find( [objid: param.refno ]  ).first();
		if( o ) {
			if(o.webfee==null) o.webfee = 0;
			o.total = o.amount + o.webfee;
			if(o.payment?.objid) o.paid = true;			
		}
		return o;
	}

	@ProxyMethod
	public def getPaymentPartner(def o ) {
		return paypartner_db.find( o ).first();
	}

	@ProxyMethod
	public def getPaymentPartnerOptions( param ) {
		return optionEm.find( [partnerid : param.partnerid ] ).list(); 
	}

	@ProxyMethod
	public def getPaymentPartnerOption( param ) {
		def paypartneroption = optionEm.find( [objid : param.payoption ] ).first(); 
		def paypartner = paypartneroption.paypartner;
		if( paypartneroption.info ) {
			paypartner.info.putAll( paypartneroption.remove("info") );
		}		
		return paypartneroption;
	}

	@ProxyMethod
	public def getUnpostedPaymentList( def o ) {
		return pay_db.getUnpostedPaymentList([orgcode: o.orgcode]);
	}

	/*************************************************************************************************
	* This is called when asking to display EOR. This will return the receipt number and orgcode 
	*************************************************************************************************/
	@ProxyMethod
	public def getReceiptInfo( def o ) {
		if(o.receiptno) {
			def rct = pay_db.find( [receiptno: o.receiptno ] ).first();
			if( rct ) {
				return [partnerid: rct.orgcode, receiptno: rct.receiptno ];
			}
			throw new Exception("Receipt no does not exist");
		}
		else if( o.refno ) {
			def rct = pay_db.find( [paymentrefid: o.refno ] ).first();
			if( rct ) {
				if(!rct.receiptno) throw new Exception("This transaction does not yet have an associated electronic receipt. If you have a already paid, the OR might still be processed. Please inquire with the agency");
				return [partnerid: rct.orgcode, receiptno: rct.receiptno];
			}
			throw new Exception("This payment reference does not exist");
		}	
		throw new Exception("Please provide receiptno or refno parameter");
	}

}